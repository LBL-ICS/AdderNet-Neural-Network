$date
2025-07-29T19:21+0000
$end
$version
0.2
$end
$comment

$end
$timescale 1ns  $end
$scope module FPAdder $end
 $var wire 4 ! io_in_a $end
 $var wire 4 " io_in_b $end
 $var wire 3 # normExp $end
 $var wire 1 $ io_valid_in $end
 $var wire 3 % manA $end
 $var wire 3 & manB $end
 $var wire 2 ' expDiff $end
 $var wire 2 ( normMan $end
 $var wire 1 ) reset $end
 $var wire 2 * commonExp $end
 $var wire 5 + sum $end
 $var wire 5 , result $end
 $var wire 1 - validOutReg $end
 $var wire 4 . inAReg $end
 $var wire 5 / outReg $end
 $var wire 5 0 shiftedSum $end
 $var wire 3 1 leadingOnePos $end
 $var wire 4 2 alignedManA $end
 $var wire 1 3 io_valid_out $end
 $var wire 4 4 alignedManB $end
 $var wire 1 5 clock $end
 $var wire 4 6 io_out $end
 $var wire 2 7 fracA $end
 $var wire 2 8 fracB $end
 $var wire 4 9 inBReg $end
 $var wire 1 : printf $end
 $var wire 2 ; expB $end
 $var wire 1 < validReg0 $end
 $var wire 2 = expA $end
$upscope $end
$enddefinitions $end
$dumpvars
b00 8
b00 7
03
b00 =
05
b00 ;
0:
0<
b00 (
b00 '
b00 *
b00000 +
b00000 ,
b00000 /
b00000 0
b000 &
b0000 "
b000 #
b0000 !
b000 %
b000 1
b0000 4
b0000 2
0$
b0000 .
0)
b0000 9
0-
b0000 6
$end
#0
1)
#1
15
#6
1$
05
0)
#11
15
1<
#16
b0001 "
05
#21
b100 1
13
b0001 4
15
b001 &
b01 8
b0001 9
b00001 +
1-
#26
b0100 !
b0101 "
05
#31
b0100 2
b0101 4
b100 %
15
b101 &
b0101 9
b01 *
b01001 +
b01 ;
b01 =
b0100 .
#36
b0110 !
b0111 "
05
#41
b0110 2
b0111 4
b110 %
15
b111 &
b10 7
b11 8
b0111 9
b01101 +
b0110 .
#46
b0000 !
b0000 "
0$
05
#51
b000 %
b000 &
b00 *
b00000 +
b0000 .
b000 1
b0000 2
b0000 4
15
b00 7
b00 8
b0000 9
b00 ;
0<
b00 =
#56
05
#61
03
15
0-
#66
05
#71
15
#76
05
#81
15
#86
05
#91
15
#96
05
#101
15
#106
05
