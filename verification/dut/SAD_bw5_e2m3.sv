// Generated by CIRCT firtool-1.62.0
module FPSubtractorAbs_5_1(
  input        clock,
               reset,
  input  [4:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [4:0] io_out,
  output       io_valid_out
);

  reg       sr_valid_0;
  reg [4:0] sr_data_0;
  always @(posedge clock) begin
    if (reset) begin
      sr_valid_0 <= 1'h0;
      sr_data_0 <= 5'h0;
    end
    else begin
      sr_valid_0 <= io_valid_in;
      if (io_valid_in) begin
        automatic logic        aIsInf = (&(io_in_a[4:3])) & ~(|(io_in_a[2:0]));
        automatic logic        bIsInf = (&(io_in_b[4:3])) & ~(|(io_in_b[2:0]));
        automatic logic        oneInf = aIsInf ^ bIsInf;
        automatic logic        _GEN =
          (&(io_in_a[4:3])) & (|(io_in_a[2:0])) | (&(io_in_b[4:3])) & (|(io_in_b[2:0]))
          | aIsInf & bIsInf;
        automatic logic [3:0]  normFracA = {|(io_in_a[4:3]), io_in_a[2:0]};
        automatic logic [3:0]  normFracB = {|(io_in_b[4:3]), io_in_b[2:0]};
        automatic logic [3:0]  eA =
          (|(io_in_a[4:3])) ? {2'h0, io_in_a[4:3]} - 4'h1 : 4'h0;
        automatic logic [3:0]  eB =
          (|(io_in_b[4:3])) ? {2'h0, io_in_b[4:3]} - 4'h1 : 4'h0;
        automatic logic        aIsLarger =
          eA == eB ? normFracA > normFracB : $signed(eA) > $signed(eB);
        automatic logic [3:0]  _expDiffS_T = eA - eB;
        automatic logic [3:0]  expDiffU =
          $signed(_expDiffS_T) < 4'sh0 ? 4'h0 - _expDiffS_T : _expDiffS_T;
        automatic logic [3:0]  _GEN_0 = aIsLarger ? normFracB : normFracA;
        automatic logic        overShift = expDiffU > 4'h6;
        automatic logic [3:0]  coreSh = overShift ? 4'h6 : expDiffU;
        automatic logic [6:0]  shifted = {_GEN_0, 3'h0} >> coreSh;
        automatic logic [21:0] _mask_T = 22'h1 << coreSh;
        automatic logic [6:0]  _mask_T_1 = _mask_T[6:0] - 7'h1;
        automatic logic [6:0]  _diffExt_T =
          {aIsLarger ? normFracA : normFracB, 3'h0}
          - {shifted[6:1],
             shifted[0] | (|(_mask_T_1[6:3] & _GEN_0)) | overShift & (|_GEN_0)};
        automatic logic        isZero = _diffExt_T == 7'h0;
        automatic logic [2:0]  shiftAmt =
          isZero
            ? 3'h7
            : _diffExt_T[6]
                ? 3'h0
                : _diffExt_T[5]
                    ? 3'h1
                    : _diffExt_T[4]
                        ? 3'h2
                        : _diffExt_T[3]
                            ? 3'h3
                            : _diffExt_T[2] ? 3'h4 : _diffExt_T[1] ? 3'h5 : 3'h6;
        automatic logic [13:0] _shiftedExt_T = {7'h0, _diffExt_T} << shiftAmt;
        automatic logic [6:0]  shiftedExt = isZero ? 7'h0 : _shiftedExt_T[6:0];
        automatic logic [3:0]  newExp =
          isZero ? 4'h0 : (aIsLarger ? eA : eB) - {1'h0, shiftAmt};
        automatic logic        _GEN_1 = $signed(newExp) < 4'sh0;
        automatic logic [3:0]  _under_T = 4'h0 - newExp;
        automatic logic [6:0]  denFull = shiftedExt >> (_under_T[3] ? 4'h7 : _under_T);
        automatic logic [3:0]  _sum_T_1 =
          {1'h0, denFull[5:3]}
          + {3'h0, denFull[2] & (denFull[1] | denFull[0] | denFull[3])};
        automatic logic [3:0]  _sum_T_3 =
          {1'h0, shiftedExt[5:3]}
          + {3'h0, shiftedExt[2] & (shiftedExt[1] | shiftedExt[0] | shiftedExt[3])};
        sr_data_0 <=
          _GEN | oneInf
            ? (_GEN ? 5'h1C : oneInf ? 5'h18 : 5'h0)
            : {isZero
                 ? 2'h0
                 : _GEN_1
                     ? {1'h0, _sum_T_1[3]}
                     : newExp[1:0] + {1'h0, _sum_T_3[3]} + 2'h1,
               isZero
                 ? 3'h0
                 : _GEN_1
                     ? (_sum_T_1[3] ? 3'h0 : _sum_T_1[2:0])
                     : _sum_T_3[3] ? 3'h0 : _sum_T_3[2:0]};
      end
    end
  end // always @(posedge)
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module LZC(
  input  [3:0] io_in,
  output [2:0] io_out,
  output       io_isZero
);

  wire [3:0] rev = {io_in[0], io_in[1], io_in[2], io_in[3]};
  assign io_out =
    (|rev) ? {1'h0, io_in[3] ? 2'h0 : io_in[2] ? 2'h1 : {1'h1, ~(io_in[1])}} : 3'h4;
  assign io_isZero = ~(|rev);
endmodule

module FPAdder_5_1(
  input        clock,
               reset,
  input  [4:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [4:0] io_out,
  output       io_valid_out
);

  wire [2:0] _lzc_io_out;
  wire       _lzc_io_isZero;
  wire [3:0] eA = (|(io_in_a[4:3])) ? {2'h0, io_in_a[4:3]} - 4'h1 : 4'h0;
  wire [3:0] eB = (|(io_in_b[4:3])) ? {2'h0, io_in_b[4:3]} - 4'h1 : 4'h0;
  wire [3:0] _expDiffs_T = eA - eB;
  wire       expAGtB = $signed(eA) > $signed(eB);
  wire [3:0] expDiff = $signed(_expDiffs_T) < 4'sh0 ? 4'h0 - _expDiffs_T : _expDiffs_T;
  wire [3:0] _GEN = {|(io_in_a[4:3]), io_in_a[2:0]};
  wire [3:0] _GEN_0 = {|(io_in_b[4:3]), io_in_b[2:0]};
  wire [3:0] _GEN_1 = expAGtB ? _GEN_0 : _GEN;
  wire [4:0] smallPre = {1'h0, _GEN_1};
  wire [2:0] _sVal_T_1 = expDiff > 4'h5 ? 3'h5 : expDiff[2:0];
  wire [4:0] fracSum = {1'h0, expAGtB ? _GEN : _GEN_0} + (smallPre >> _sVal_T_1);
  reg        sr_valid_0;
  reg  [4:0] sr_data_0;
  always @(posedge clock) begin
    if (reset)
      sr_valid_0 <= 1'h0;
    else
      sr_valid_0 <= io_valid_in;
    if (io_valid_in) begin
      automatic logic        anyNaNIn =
        (&(io_in_a[4:3])) & (|(io_in_a[2:0])) | (&(io_in_b[4:3])) & (|(io_in_b[2:0]));
      automatic logic        anyInfIn =
        (&(io_in_a[4:3])) & ~(|(io_in_a[2:0])) | (&(io_in_b[4:3])) & ~(|(io_in_b[2:0]));
      automatic logic [3:0]  expOut = expAGtB ? eA : eB;
      automatic logic        _roundBitLeft_k0_T = _sVal_T_1 == 3'h0;
      automatic logic [11:0] _alignMask_T_1 = 12'h1 << _sVal_T_1;
      automatic logic [3:0]  _GEN_2 =
        (_roundBitLeft_k0_T ? 4'h0 : _alignMask_T_1[3:0] - 4'h1) & _GEN_1;
      automatic logic [10:0] _shiftedFrac_T_2 = {7'h0, fracSum[3:0]} << _lzc_io_out;
      automatic logic [3:0]  shiftedFrac =
        fracSum[4] ? fracSum[4:1] : _lzc_io_isZero ? 4'h0 : _shiftedFrac_T_2[3:0];
      automatic logic [2:0]  _lowerMaskLeft_T = _lzc_io_out - 3'h1;
      automatic logic [2:0]  _stickyLeft_k0_T_1 = _sVal_T_1 - 3'h1;
      automatic logic        _stickyLeft_T = _lzc_io_out == 3'h0;
      automatic logic [11:0] _stickyLeft_k0_T_3 = 12'h1 << _stickyLeft_k0_T_1;
      automatic logic [10:0] _lowerMaskLeft_T_2 = 11'h1 << _lowerMaskLeft_T;
      automatic logic [4:0]  _roundBitLeft_k0_T_3 = smallPre >> _stickyLeft_k0_T_1;
      automatic logic [3:0]  _roundBitLeft_kpos_T_2 = fracSum[3:0] >> _lowerMaskLeft_T;
      automatic logic [4:0]  _roundedWide_T_1 =
        {1'h0, shiftedFrac}
        + {4'h0,
           (fracSum[4]
              ? fracSum[0]
              : _stickyLeft_T
                  ? ~_roundBitLeft_k0_T & _roundBitLeft_k0_T_3[0]
                  : _roundBitLeft_kpos_T_2[0])
             & ((fracSum[4]
                   ? (|_GEN_2)
                   : _stickyLeft_T
                       ? (|(_sVal_T_1[2:1]))
                         & (|(_stickyLeft_k0_T_3[3:0] - 4'h1 & _GEN_1))
                       : (|_GEN_2) | (|(_lowerMaskLeft_T_2[3:0] - 4'h1 & fracSum[3:0])))
                | shiftedFrac[0])};
      automatic logic [3:0]  _expAfter_T_1 =
        (fracSum[4]
           ? expOut + 4'h1
           : _lzc_io_isZero ? 4'h0 : expOut - {1'h0, _lzc_io_out})
        + {3'h0, _roundedWide_T_1[4]};
      automatic logic        _GEN_3 = shiftedFrac == 4'h0;
      automatic logic        _GEN_4 = $signed(_expAfter_T_1) < 4'sh0;
      automatic logic [3:0]  _sRaw_T = 4'h0 - expOut + {3'h0, fracSum[3]};
      automatic logic        _GEN_5 = $signed(_expAfter_T_1) > 4'sh1;
      automatic logic [3:0]  den = fracSum[3:0] >> (_sRaw_T > 4'h4 ? 4'h4 : _sRaw_T);
      sr_data_0 <=
        anyNaNIn | anyInfIn
          ? (anyNaNIn ? 5'h1C : anyInfIn ? 5'h18 : 5'h0)
          : {_GEN_3 | _GEN_4 ? 2'h0 : _GEN_5 ? 2'h3 : _expAfter_T_1[1:0] + 2'h1,
             _GEN_3
               ? 3'h0
               : _GEN_4
                   ? den[2:0]
                   : _GEN_5
                       ? 3'h0
                       : _roundedWide_T_1[4]
                           ? _roundedWide_T_1[3:1]
                           : _roundedWide_T_1[2:0]};
    end
  end // always @(posedge)
  LZC lzc (
    .io_in     (fracSum[3:0]),
    .io_out    (_lzc_io_out),
    .io_isZero (_lzc_io_isZero)
  );
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module SAD_bw5_e2m3(
  input        clock,
               reset,
  input  [4:0] io_in_vec_a_0,
               io_in_vec_a_1,
               io_in_vec_a_2,
               io_in_vec_b_0,
               io_in_vec_b_1,
               io_in_vec_b_2,
  input        io_valid_in,
  output [4:0] io_out_s,
  output       io_valid_out
);

  wire [4:0] _adderInst_io_out;
  wire       _adderInst_io_valid_out;
  wire [4:0] _SubInst_2_io_out;
  wire       _SubInst_2_io_valid_out;
  wire [4:0] _SubInst_1_io_out;
  wire       _SubInst_1_io_valid_out;
  wire [4:0] _SubInst_io_out;
  wire       _SubInst_io_valid_out;
  reg  [4:0] adder_Wire_1_r;
  reg        nextValid_1_r;
  always @(posedge clock) begin
    adder_Wire_1_r <= _SubInst_2_io_out;
    nextValid_1_r <= _SubInst_2_io_valid_out;
  end // always @(posedge)
  FPSubtractorAbs_5_1 SubInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_0),
    .io_in_b      (io_in_vec_b_0),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_io_out),
    .io_valid_out (_SubInst_io_valid_out)
  );
  FPSubtractorAbs_5_1 SubInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_1),
    .io_in_b      (io_in_vec_b_1),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_1_io_out),
    .io_valid_out (_SubInst_1_io_valid_out)
  );
  FPSubtractorAbs_5_1 SubInst_2 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_2),
    .io_in_b      (io_in_vec_b_2),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_2_io_out),
    .io_valid_out (_SubInst_2_io_valid_out)
  );
  FPAdder_5_1 adderInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_SubInst_io_out),
    .io_in_b      (_SubInst_1_io_out),
    .io_valid_in  (_SubInst_io_valid_out & _SubInst_1_io_valid_out),
    .io_out       (_adderInst_io_out),
    .io_valid_out (_adderInst_io_valid_out)
  );
  FPAdder_5_1 adderInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_adderInst_io_out),
    .io_in_b      (adder_Wire_1_r),
    .io_valid_in  (_adderInst_io_valid_out & nextValid_1_r),
    .io_out       (io_out_s),
    .io_valid_out (io_valid_out)
  );
endmodule

