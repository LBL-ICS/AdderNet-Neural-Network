// Generated by CIRCT firtool-1.62.0
module FPSubtractorAbs_5_1(
  input        clock,
               reset,
  input  [4:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [4:0] io_out,
  output       io_valid_out
);

  reg       sr_valid_0;
  reg [4:0] sr_data_0;
  always @(posedge clock) begin
    if (reset) begin
      sr_valid_0 <= 1'h0;
      sr_data_0 <= 5'h0;
    end
    else begin
      sr_valid_0 <= io_valid_in;
      if (io_valid_in) begin
        automatic logic        aIsInf = (&(io_in_a[4:2])) & ~(|(io_in_a[1:0]));
        automatic logic        bIsInf = (&(io_in_b[4:2])) & ~(|(io_in_b[1:0]));
        automatic logic        oneInf = aIsInf ^ bIsInf;
        automatic logic        _GEN =
          (&(io_in_a[4:2])) & (|(io_in_a[1:0])) | (&(io_in_b[4:2])) & (|(io_in_b[1:0]))
          | aIsInf & bIsInf;
        automatic logic [2:0]  normFracA = {|(io_in_a[4:2]), io_in_a[1:0]};
        automatic logic [2:0]  normFracB = {|(io_in_b[4:2]), io_in_b[1:0]};
        automatic logic [4:0]  eA =
          (|(io_in_a[4:2])) ? {2'h0, io_in_a[4:2]} - 5'h3 : 5'h1E;
        automatic logic [4:0]  eB =
          (|(io_in_b[4:2])) ? {2'h0, io_in_b[4:2]} - 5'h3 : 5'h1E;
        automatic logic        aIsLarger =
          eA == eB ? normFracA > normFracB : $signed(eA) > $signed(eB);
        automatic logic [4:0]  _expDiffS_T = eA - eB;
        automatic logic [4:0]  expDiffU =
          $signed(_expDiffS_T) < 5'sh0 ? 5'h0 - _expDiffS_T : _expDiffS_T;
        automatic logic [2:0]  _GEN_0 = aIsLarger ? normFracB : normFracA;
        automatic logic        overShift = expDiffU > 5'h5;
        automatic logic [4:0]  coreSh = overShift ? 5'h5 : expDiffU;
        automatic logic [5:0]  shifted = {_GEN_0, 3'h0} >> coreSh;
        automatic logic [36:0] _mask_T = 37'h1 << coreSh;
        automatic logic [5:0]  _mask_T_1 = _mask_T[5:0] - 6'h1;
        automatic logic [5:0]  _diffExt_T =
          {aIsLarger ? normFracA : normFracB, 3'h0}
          - {shifted[5:1],
             shifted[0] | (|(_mask_T_1[5:3] & _GEN_0)) | overShift & (|_GEN_0)};
        automatic logic        isZero = _diffExt_T == 6'h0;
        automatic logic [2:0]  shiftAmt =
          isZero
            ? 3'h6
            : _diffExt_T[5]
                ? 3'h0
                : _diffExt_T[4]
                    ? 3'h1
                    : _diffExt_T[3]
                        ? 3'h2
                        : _diffExt_T[2] ? 3'h3 : {2'h2, ~(_diffExt_T[1])};
        automatic logic [12:0] _shiftedExt_T = {7'h0, _diffExt_T} << shiftAmt;
        automatic logic [5:0]  shiftedExt = isZero ? 6'h0 : _shiftedExt_T[5:0];
        automatic logic [4:0]  newExp =
          isZero ? 5'h0 : (aIsLarger ? eA : eB) - {2'h0, shiftAmt};
        automatic logic        _GEN_1 = $signed(newExp) < -5'sh2;
        automatic logic [4:0]  _under_T = 5'h1E - newExp;
        automatic logic [5:0]  denFull =
          shiftedExt >> (_under_T > 5'h6 ? 5'h6 : _under_T);
        automatic logic [2:0]  _sum_T_1 =
          {1'h0, denFull[4:3]}
          + {2'h0, denFull[2] & (denFull[1] | denFull[0] | denFull[3])};
        automatic logic [2:0]  _sum_T_3 =
          {1'h0, shiftedExt[4:3]}
          + {2'h0, shiftedExt[2] & (shiftedExt[1] | shiftedExt[0] | shiftedExt[3])};
        sr_data_0 <=
          _GEN | oneInf
            ? (_GEN ? 5'h1E : oneInf ? 5'h1C : 5'h0)
            : {isZero
                 ? 3'h0
                 : _GEN_1
                     ? {2'h0, _sum_T_1[2]}
                     : newExp[2:0] + {2'h0, _sum_T_3[2]} + 3'h3,
               isZero
                 ? 2'h0
                 : _GEN_1
                     ? (_sum_T_1[2] ? 2'h0 : _sum_T_1[1:0])
                     : _sum_T_3[2] ? 2'h0 : _sum_T_3[1:0]};
      end
    end
  end // always @(posedge)
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module LZC(
  input  [2:0] io_in,
  output [1:0] io_out,
  output       io_isZero
);

  wire [2:0] rev = {io_in[0], io_in[1], io_in[2]};
  assign io_out = (|rev) ? (io_in[2] ? 2'h0 : io_in[1] ? 2'h1 : 2'h2) : 2'h3;
  assign io_isZero = ~(|rev);
endmodule

module FPAdder_5_1(
  input        clock,
               reset,
  input  [4:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [4:0] io_out,
  output       io_valid_out
);

  wire [1:0] _lzc_io_out;
  wire       _lzc_io_isZero;
  wire [4:0] eA = (|(io_in_a[4:2])) ? {2'h0, io_in_a[4:2]} - 5'h3 : 5'h1E;
  wire [4:0] eB = (|(io_in_b[4:2])) ? {2'h0, io_in_b[4:2]} - 5'h3 : 5'h1E;
  wire [4:0] _expDiffs_T = eA - eB;
  wire       expAGtB = $signed(eA) > $signed(eB);
  wire [4:0] expDiff = $signed(_expDiffs_T) < 5'sh0 ? 5'h0 - _expDiffs_T : _expDiffs_T;
  wire [2:0] _GEN = {|(io_in_a[4:2]), io_in_a[1:0]};
  wire [2:0] _GEN_0 = {|(io_in_b[4:2]), io_in_b[1:0]};
  wire [2:0] _GEN_1 = expAGtB ? _GEN_0 : _GEN;
  wire [3:0] smallPre = {1'h0, _GEN_1};
  wire [2:0] _sVal_T_1 = expDiff > 5'h4 ? 3'h4 : expDiff[2:0];
  wire [3:0] fracSum = {1'h0, expAGtB ? _GEN : _GEN_0} + (smallPre >> _sVal_T_1);
  reg        sr_valid_0;
  reg  [4:0] sr_data_0;
  always @(posedge clock) begin
    if (reset)
      sr_valid_0 <= 1'h0;
    else
      sr_valid_0 <= io_valid_in;
    if (io_valid_in) begin
      automatic logic        anyNaNIn =
        (&(io_in_a[4:2])) & (|(io_in_a[1:0])) | (&(io_in_b[4:2])) & (|(io_in_b[1:0]));
      automatic logic        anyInfIn =
        (&(io_in_a[4:2])) & ~(|(io_in_a[1:0])) | (&(io_in_b[4:2])) & ~(|(io_in_b[1:0]));
      automatic logic [4:0]  expOut = expAGtB ? eA : eB;
      automatic logic        _roundBitLeft_k0_T = _sVal_T_1 == 3'h0;
      automatic logic [10:0] _alignMask_T_1 = 11'h1 << _sVal_T_1;
      automatic logic [2:0]  _GEN_2 =
        (_roundBitLeft_k0_T ? 3'h0 : _alignMask_T_1[2:0] - 3'h1) & _GEN_1;
      automatic logic [5:0]  _shiftedFrac_T_2 = {3'h0, fracSum[2:0]} << _lzc_io_out;
      automatic logic [2:0]  shiftedFrac =
        fracSum[3] ? fracSum[3:1] : _lzc_io_isZero ? 3'h0 : _shiftedFrac_T_2[2:0];
      automatic logic [1:0]  _lowerMaskLeft_T = _lzc_io_out - 2'h1;
      automatic logic [2:0]  _stickyLeft_k0_T_1 = _sVal_T_1 - 3'h1;
      automatic logic        _stickyLeft_T = _lzc_io_out == 2'h0;
      automatic logic [10:0] _stickyLeft_k0_T_3 = 11'h1 << _stickyLeft_k0_T_1;
      automatic logic [5:0]  _lowerMaskLeft_T_2 = 6'h1 << _lowerMaskLeft_T;
      automatic logic [3:0]  _roundBitLeft_k0_T_3 = smallPre >> _stickyLeft_k0_T_1;
      automatic logic [2:0]  _roundBitLeft_kpos_T_2 = fracSum[2:0] >> _lowerMaskLeft_T;
      automatic logic [3:0]  _roundedWide_T_1 =
        {1'h0, shiftedFrac}
        + {3'h0,
           (fracSum[3]
              ? fracSum[0]
              : _stickyLeft_T
                  ? ~_roundBitLeft_k0_T & _roundBitLeft_k0_T_3[0]
                  : _roundBitLeft_kpos_T_2[0])
             & ((fracSum[3]
                   ? (|_GEN_2)
                   : _stickyLeft_T
                       ? (|(_sVal_T_1[2:1]))
                         & (|(_stickyLeft_k0_T_3[2:0] - 3'h1 & _GEN_1))
                       : (|_GEN_2) | (|(_lowerMaskLeft_T_2[2:0] - 3'h1 & fracSum[2:0])))
                | shiftedFrac[0])};
      automatic logic [4:0]  _expAfter_T_1 =
        (fracSum[3]
           ? expOut + 5'h1
           : _lzc_io_isZero ? 5'h0 : expOut - {3'h0, _lzc_io_out})
        + {4'h0, _roundedWide_T_1[3]};
      automatic logic        _GEN_3 = shiftedFrac == 3'h0;
      automatic logic        _GEN_4 = $signed(_expAfter_T_1) < -5'sh2;
      automatic logic [4:0]  _sRaw_T = 5'h1E - expOut + {4'h0, fracSum[2]};
      automatic logic        _GEN_5 = $signed(_expAfter_T_1) > 5'sh3;
      automatic logic [4:0]  den =
        {2'h0, fracSum[2:0]} >> ((|(_sRaw_T[4:2])) ? 5'h3 : _sRaw_T);
      sr_data_0 <=
        anyNaNIn | anyInfIn
          ? (anyNaNIn ? 5'h1E : anyInfIn ? 5'h1C : 5'h0)
          : {_GEN_3 | _GEN_4 ? 3'h0 : _GEN_5 ? 3'h7 : _expAfter_T_1[2:0] + 3'h3,
             _GEN_3
               ? 2'h0
               : _GEN_4
                   ? den[1:0]
                   : _GEN_5
                       ? 2'h0
                       : _roundedWide_T_1[3]
                           ? _roundedWide_T_1[2:1]
                           : _roundedWide_T_1[1:0]};
    end
  end // always @(posedge)
  LZC lzc (
    .io_in     (fracSum[2:0]),
    .io_out    (_lzc_io_out),
    .io_isZero (_lzc_io_isZero)
  );
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module SAD_bw5_e3m2(
  input        clock,
               reset,
  input  [4:0] io_in_vec_a_0,
               io_in_vec_a_1,
               io_in_vec_a_2,
               io_in_vec_b_0,
               io_in_vec_b_1,
               io_in_vec_b_2,
  input        io_valid_in,
  output [4:0] io_out_s,
  output       io_valid_out
);

  wire [4:0] _adderInst_io_out;
  wire       _adderInst_io_valid_out;
  wire [4:0] _SubInst_2_io_out;
  wire       _SubInst_2_io_valid_out;
  wire [4:0] _SubInst_1_io_out;
  wire       _SubInst_1_io_valid_out;
  wire [4:0] _SubInst_io_out;
  wire       _SubInst_io_valid_out;
  reg  [4:0] adder_Wire_1_r;
  reg        nextValid_1_r;
  always @(posedge clock) begin
    adder_Wire_1_r <= _SubInst_2_io_out;
    nextValid_1_r <= _SubInst_2_io_valid_out;
  end // always @(posedge)
  FPSubtractorAbs_5_1 SubInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_0),
    .io_in_b      (io_in_vec_b_0),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_io_out),
    .io_valid_out (_SubInst_io_valid_out)
  );
  FPSubtractorAbs_5_1 SubInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_1),
    .io_in_b      (io_in_vec_b_1),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_1_io_out),
    .io_valid_out (_SubInst_1_io_valid_out)
  );
  FPSubtractorAbs_5_1 SubInst_2 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_2),
    .io_in_b      (io_in_vec_b_2),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_2_io_out),
    .io_valid_out (_SubInst_2_io_valid_out)
  );
  FPAdder_5_1 adderInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_SubInst_io_out),
    .io_in_b      (_SubInst_1_io_out),
    .io_valid_in  (_SubInst_io_valid_out & _SubInst_1_io_valid_out),
    .io_out       (_adderInst_io_out),
    .io_valid_out (_adderInst_io_valid_out)
  );
  FPAdder_5_1 adderInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_adderInst_io_out),
    .io_in_b      (adder_Wire_1_r),
    .io_valid_in  (_adderInst_io_valid_out & nextValid_1_r),
    .io_out       (io_out_s),
    .io_valid_out (io_valid_out)
  );
endmodule

