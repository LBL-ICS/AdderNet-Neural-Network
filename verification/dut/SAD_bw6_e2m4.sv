// Generated by CIRCT firtool-1.62.0
module FPSubtractorAbs_6_1(
  input        clock,
               reset,
  input  [5:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [5:0] io_out,
  output       io_valid_out
);

  reg       sr_valid_0;
  reg [5:0] sr_data_0;
  always @(posedge clock) begin
    if (reset) begin
      sr_valid_0 <= 1'h0;
      sr_data_0 <= 6'h0;
    end
    else begin
      sr_valid_0 <= io_valid_in;
      if (io_valid_in) begin
        automatic logic        aIsInf = (&(io_in_a[5:4])) & ~(|(io_in_a[3:0]));
        automatic logic        bIsInf = (&(io_in_b[5:4])) & ~(|(io_in_b[3:0]));
        automatic logic        oneInf = aIsInf ^ bIsInf;
        automatic logic        _GEN =
          (&(io_in_a[5:4])) & (|(io_in_a[3:0])) | (&(io_in_b[5:4])) & (|(io_in_b[3:0]))
          | aIsInf & bIsInf;
        automatic logic [4:0]  normFracA = {|(io_in_a[5:4]), io_in_a[3:0]};
        automatic logic [4:0]  normFracB = {|(io_in_b[5:4]), io_in_b[3:0]};
        automatic logic [3:0]  eA =
          (|(io_in_a[5:4])) ? {2'h0, io_in_a[5:4]} - 4'h1 : 4'h0;
        automatic logic [3:0]  eB =
          (|(io_in_b[5:4])) ? {2'h0, io_in_b[5:4]} - 4'h1 : 4'h0;
        automatic logic        aIsLarger =
          eA == eB ? normFracA > normFracB : $signed(eA) > $signed(eB);
        automatic logic [3:0]  _expDiffS_T = eA - eB;
        automatic logic [3:0]  expDiffU =
          $signed(_expDiffS_T) < 4'sh0 ? 4'h0 - _expDiffS_T : _expDiffS_T;
        automatic logic [4:0]  _GEN_0 = aIsLarger ? normFracB : normFracA;
        automatic logic [3:0]  coreSh = expDiffU[3] ? 4'h7 : expDiffU;
        automatic logic [7:0]  shifted = {_GEN_0, 3'h0} >> coreSh;
        automatic logic [22:0] _mask_T = 23'h1 << coreSh;
        automatic logic [7:0]  _mask_T_1 = _mask_T[7:0] - 8'h1;
        automatic logic [7:0]  _diffExt_T =
          {aIsLarger ? normFracA : normFracB, 3'h0}
          - {shifted[7:1],
             shifted[0] | (|(_mask_T_1[7:3] & _GEN_0)) | expDiffU[3] & (|_GEN_0)};
        automatic logic        isZero = _diffExt_T == 8'h0;
        automatic logic [3:0]  shiftAmt =
          isZero
            ? 4'h8
            : {1'h0,
               _diffExt_T[7]
                 ? 3'h0
                 : _diffExt_T[6]
                     ? 3'h1
                     : _diffExt_T[5]
                         ? 3'h2
                         : _diffExt_T[4]
                             ? 3'h3
                             : _diffExt_T[3]
                                 ? 3'h4
                                 : _diffExt_T[2] ? 3'h5 : {2'h3, ~(_diffExt_T[1])}};
        automatic logic [22:0] _shiftedExt_T = {15'h0, _diffExt_T} << shiftAmt;
        automatic logic [7:0]  shiftedExt = isZero ? 8'h0 : _shiftedExt_T[7:0];
        automatic logic [3:0]  newExp = isZero ? 4'h0 : (aIsLarger ? eA : eB) - shiftAmt;
        automatic logic        _GEN_1 = $signed(newExp) < 4'sh0;
        automatic logic [3:0]  _under_T = 4'h0 - newExp;
        automatic logic [7:0]  denFull =
          shiftedExt >> (_under_T > 4'h8 ? 4'h8 : _under_T);
        automatic logic [4:0]  _sum_T_1 =
          {1'h0, denFull[6:3]}
          + {4'h0, denFull[2] & (denFull[1] | denFull[0] | denFull[3])};
        automatic logic [4:0]  _sum_T_3 =
          {1'h0, shiftedExt[6:3]}
          + {4'h0, shiftedExt[2] & (shiftedExt[1] | shiftedExt[0] | shiftedExt[3])};
        sr_data_0 <=
          _GEN | oneInf
            ? (_GEN ? 6'h38 : oneInf ? 6'h30 : 6'h0)
            : {isZero
                 ? 2'h0
                 : _GEN_1
                     ? {1'h0, _sum_T_1[4]}
                     : newExp[1:0] + {1'h0, _sum_T_3[4]} + 2'h1,
               isZero
                 ? 4'h0
                 : _GEN_1
                     ? (_sum_T_1[4] ? 4'h0 : _sum_T_1[3:0])
                     : _sum_T_3[4] ? 4'h0 : _sum_T_3[3:0]};
      end
    end
  end // always @(posedge)
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module LZC(
  input  [4:0] io_in,
  output [2:0] io_out,
  output       io_isZero
);

  wire [4:0] rev = {io_in[0], io_in[1], io_in[2], io_in[3], io_in[4]};
  assign io_out =
    (|rev)
      ? (io_in[4] ? 3'h0 : io_in[3] ? 3'h1 : io_in[2] ? 3'h2 : io_in[1] ? 3'h3 : 3'h4)
      : 3'h5;
  assign io_isZero = ~(|rev);
endmodule

module FPAdder_6_1(
  input        clock,
               reset,
  input  [5:0] io_in_a,
               io_in_b,
  input        io_valid_in,
  output [5:0] io_out,
  output       io_valid_out
);

  wire [2:0] _lzc_io_out;
  wire       _lzc_io_isZero;
  wire [3:0] eA = (|(io_in_a[5:4])) ? {2'h0, io_in_a[5:4]} - 4'h1 : 4'h0;
  wire [3:0] eB = (|(io_in_b[5:4])) ? {2'h0, io_in_b[5:4]} - 4'h1 : 4'h0;
  wire [3:0] _expDiffs_T = eA - eB;
  wire       expAGtB = $signed(eA) > $signed(eB);
  wire [3:0] expDiff = $signed(_expDiffs_T) < 4'sh0 ? 4'h0 - _expDiffs_T : _expDiffs_T;
  wire [4:0] _GEN = {|(io_in_a[5:4]), io_in_a[3:0]};
  wire [4:0] _GEN_0 = {|(io_in_b[5:4]), io_in_b[3:0]};
  wire [4:0] _GEN_1 = expAGtB ? _GEN_0 : _GEN;
  wire [5:0] smallPre = {1'h0, _GEN_1};
  wire [2:0] _sVal_T_1 = expDiff > 4'h6 ? 3'h6 : expDiff[2:0];
  wire [5:0] fracSum = {1'h0, expAGtB ? _GEN : _GEN_0} + (smallPre >> _sVal_T_1);
  reg        sr_valid_0;
  reg  [5:0] sr_data_0;
  always @(posedge clock) begin
    if (reset)
      sr_valid_0 <= 1'h0;
    else
      sr_valid_0 <= io_valid_in;
    if (io_valid_in) begin
      automatic logic        anyNaNIn =
        (&(io_in_a[5:4])) & (|(io_in_a[3:0])) | (&(io_in_b[5:4])) & (|(io_in_b[3:0]));
      automatic logic        anyInfIn =
        (&(io_in_a[5:4])) & ~(|(io_in_a[3:0])) | (&(io_in_b[5:4])) & ~(|(io_in_b[3:0]));
      automatic logic [3:0]  expOut = expAGtB ? eA : eB;
      automatic logic        _roundBitLeft_k0_T = _sVal_T_1 == 3'h0;
      automatic logic [12:0] _alignMask_T_1 = 13'h1 << _sVal_T_1;
      automatic logic [4:0]  _GEN_2 =
        (_roundBitLeft_k0_T ? 5'h0 : _alignMask_T_1[4:0] - 5'h1) & _GEN_1;
      automatic logic [11:0] _shiftedFrac_T_2 = {7'h0, fracSum[4:0]} << _lzc_io_out;
      automatic logic [4:0]  shiftedFrac =
        fracSum[5] ? fracSum[5:1] : _lzc_io_isZero ? 5'h0 : _shiftedFrac_T_2[4:0];
      automatic logic [2:0]  _lowerMaskLeft_T = _lzc_io_out - 3'h1;
      automatic logic [2:0]  _stickyLeft_k0_T_1 = _sVal_T_1 - 3'h1;
      automatic logic        _stickyLeft_T = _lzc_io_out == 3'h0;
      automatic logic [12:0] _stickyLeft_k0_T_3 = 13'h1 << _stickyLeft_k0_T_1;
      automatic logic [11:0] _lowerMaskLeft_T_2 = 12'h1 << _lowerMaskLeft_T;
      automatic logic [5:0]  _roundBitLeft_k0_T_3 = smallPre >> _stickyLeft_k0_T_1;
      automatic logic [4:0]  _roundBitLeft_kpos_T_2 = fracSum[4:0] >> _lowerMaskLeft_T;
      automatic logic [5:0]  _roundedWide_T_1 =
        {1'h0, shiftedFrac}
        + {5'h0,
           (fracSum[5]
              ? fracSum[0]
              : _stickyLeft_T
                  ? ~_roundBitLeft_k0_T & _roundBitLeft_k0_T_3[0]
                  : _roundBitLeft_kpos_T_2[0])
             & ((fracSum[5]
                   ? (|_GEN_2)
                   : _stickyLeft_T
                       ? (|(_sVal_T_1[2:1]))
                         & (|(_stickyLeft_k0_T_3[4:0] - 5'h1 & _GEN_1))
                       : (|_GEN_2) | (|(_lowerMaskLeft_T_2[4:0] - 5'h1 & fracSum[4:0])))
                | shiftedFrac[0])};
      automatic logic [3:0]  _expAfter_T_1 =
        (fracSum[5]
           ? expOut + 4'h1
           : _lzc_io_isZero ? 4'h0 : expOut - {1'h0, _lzc_io_out})
        + {3'h0, _roundedWide_T_1[5]};
      automatic logic        _GEN_3 = shiftedFrac == 5'h0;
      automatic logic        _GEN_4 = $signed(_expAfter_T_1) < 4'sh0;
      automatic logic [3:0]  _sRaw_T = 4'h0 - expOut + {3'h0, fracSum[4]};
      automatic logic        _GEN_5 = $signed(_expAfter_T_1) > 4'sh1;
      automatic logic [4:0]  den = fracSum[4:0] >> (_sRaw_T > 4'h5 ? 4'h5 : _sRaw_T);
      sr_data_0 <=
        anyNaNIn | anyInfIn
          ? (anyNaNIn ? 6'h38 : anyInfIn ? 6'h30 : 6'h0)
          : {_GEN_3 | _GEN_4 ? 2'h0 : _GEN_5 ? 2'h3 : _expAfter_T_1[1:0] + 2'h1,
             _GEN_3
               ? 4'h0
               : _GEN_4
                   ? den[3:0]
                   : _GEN_5
                       ? 4'h0
                       : _roundedWide_T_1[5]
                           ? _roundedWide_T_1[4:1]
                           : _roundedWide_T_1[3:0]};
    end
  end // always @(posedge)
  LZC lzc (
    .io_in     (fracSum[4:0]),
    .io_out    (_lzc_io_out),
    .io_isZero (_lzc_io_isZero)
  );
  assign io_out = sr_data_0;
  assign io_valid_out = sr_valid_0;
endmodule

module SAD_bw6_e2m4(
  input        clock,
               reset,
  input  [5:0] io_in_vec_a_0,
               io_in_vec_a_1,
               io_in_vec_a_2,
               io_in_vec_b_0,
               io_in_vec_b_1,
               io_in_vec_b_2,
  input        io_valid_in,
  output [5:0] io_out_s,
  output       io_valid_out
);

  wire [5:0] _adderInst_io_out;
  wire       _adderInst_io_valid_out;
  wire [5:0] _SubInst_2_io_out;
  wire       _SubInst_2_io_valid_out;
  wire [5:0] _SubInst_1_io_out;
  wire       _SubInst_1_io_valid_out;
  wire [5:0] _SubInst_io_out;
  wire       _SubInst_io_valid_out;
  reg  [5:0] adder_Wire_1_r;
  reg        nextValid_1_r;
  always @(posedge clock) begin
    adder_Wire_1_r <= _SubInst_2_io_out;
    nextValid_1_r <= _SubInst_2_io_valid_out;
  end // always @(posedge)
  FPSubtractorAbs_6_1 SubInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_0),
    .io_in_b      (io_in_vec_b_0),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_io_out),
    .io_valid_out (_SubInst_io_valid_out)
  );
  FPSubtractorAbs_6_1 SubInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_1),
    .io_in_b      (io_in_vec_b_1),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_1_io_out),
    .io_valid_out (_SubInst_1_io_valid_out)
  );
  FPSubtractorAbs_6_1 SubInst_2 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (io_in_vec_a_2),
    .io_in_b      (io_in_vec_b_2),
    .io_valid_in  (io_valid_in),
    .io_out       (_SubInst_2_io_out),
    .io_valid_out (_SubInst_2_io_valid_out)
  );
  FPAdder_6_1 adderInst (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_SubInst_io_out),
    .io_in_b      (_SubInst_1_io_out),
    .io_valid_in  (_SubInst_io_valid_out & _SubInst_1_io_valid_out),
    .io_out       (_adderInst_io_out),
    .io_valid_out (_adderInst_io_valid_out)
  );
  FPAdder_6_1 adderInst_1 (
    .clock        (clock),
    .reset        (reset),
    .io_in_a      (_adderInst_io_out),
    .io_in_b      (adder_Wire_1_r),
    .io_valid_in  (_adderInst_io_valid_out & nextValid_1_r),
    .io_out       (io_out_s),
    .io_valid_out (io_valid_out)
  );
endmodule

